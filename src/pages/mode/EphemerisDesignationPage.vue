<template>
  <div class="ephemeris-mode">
    <div class="ephemeris-container">
      <!-- 1í–‰: Offset Controls -->
      <div class="row q-mb-sm align-center">
        <!-- Azimuth Offset - ê°œë³„ í…Œë‘ë¦¬ -->
        <div class="col-auto">
          <q-card flat bordered class="control-card">
            <q-card-section class="compact-control purple-1"
              style="padding: 0px 8px !important; padding-top: 0px !important; padding-bottom: 0px !important; margin: 0px !important; min-height: auto !important; height: auto !important; line-height: 1 !important; vertical-align: top !important;">
              <div class="row q-gutter-xs align-center"
                style="margin: 0px !important; padding: 0px !important; min-height: auto !important; height: auto !important;">
                <div class="col-auto position-offset-label">
                  <div class="text-subtitle2 text-weight-bold text-primary text-center">
                    Azimuth<br>Offset
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="inputs[0]" @input="(val: string) => onInputChange(0, val)" dense outlined
                    type="number" step="0.01" label="Azimuth"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
                <div class="col-auto">
                  <div class="vertical-button-group">
                    <div class="vertical-buttons">
                      <q-btn icon="add" size="sm" color="primary" dense flat @click="increment(0)" />
                      <q-btn icon="remove" size="sm" color="primary" dense flat @click="decrement(0)" />
                    </div>
                    <q-btn icon="refresh" size="sm" color="grey-7" dense flat @click="reset(0)" />
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="outputs[0]" dense outlined readonly label="Output"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
              </div>
            </q-card-section>
          </q-card>
        </div>

        <!-- Elevation Offset - ê°œë³„ í…Œë‘ë¦¬ -->
        <div class="col-auto" style="margin-left: 8px !important;">
          <q-card flat bordered class="control-card">
            <q-card-section class="compact-control purple-1"
              style="padding: 0px 8px !important; padding-top: 0px !important; padding-bottom: 0px !important; margin: 0px !important; min-height: auto !important; height: auto !important; line-height: 1 !important; vertical-align: top !important;">
              <div class="row q-gutter-xs align-center"
                style="margin: 0px !important; padding: 0px !important; min-height: auto !important; height: auto !important;">
                <div class="col-auto position-offset-label">
                  <div class="text-subtitle2 text-weight-bold text-primary text-center">
                    Elevation<br>Offset
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="inputs[1]" @input="(val: string) => onInputChange(1, val)" dense outlined
                    type="number" step="0.01" label="Elevation"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
                <div class="col-auto">
                  <div class="vertical-button-group">
                    <div class="vertical-buttons">
                      <q-btn icon="add" size="sm" color="primary" dense flat @click="increment(1)" />
                      <q-btn icon="remove" size="sm" color="primary" dense flat @click="decrement(1)" />
                    </div>
                    <q-btn icon="refresh" size="sm" color="grey-7" dense flat @click="reset(1)" />
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="outputs[1]" dense outlined readonly label="Output"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
              </div>
            </q-card-section>
          </q-card>
        </div>

        <!-- Tilt Offset - ê°œë³„ í…Œë‘ë¦¬ -->
        <div class="col-auto" style="margin-left: 8px !important;">
          <q-card flat bordered class="control-card">
            <q-card-section class="compact-control purple-1"
              style="padding: 0px 8px !important; padding-top: 0px !important; padding-bottom: 0px !important; margin: 0px !important; min-height: auto !important; height: auto !important; line-height: 1 !important; vertical-align: top !important;">
              <div class="row q-gutter-xs align-center"
                style="margin: 0px !important; padding: 0px !important; min-height: auto !important; height: auto !important;">
                <div class="col-auto position-offset-label">
                  <div class="text-subtitle2 text-weight-bold text-primary text-center">
                    Tilt<br>Offset
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="inputs[2]" @input="(val: string) => onInputChange(2, val)" dense outlined
                    type="number" step="0.01" label="Tilt"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
                <div class="col-auto">
                  <div class="vertical-button-group">
                    <div class="vertical-buttons">
                      <q-btn icon="add" size="sm" color="primary" dense flat @click="increment(2)" />
                      <q-btn icon="remove" size="sm" color="primary" dense flat @click="decrement(2)" />
                    </div>
                    <q-btn icon="refresh" size="sm" color="grey-7" dense flat @click="reset(2)" />
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="outputs[2]" dense outlined readonly label="Output"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
              </div>
            </q-card-section>
          </q-card>
        </div>

        <!-- Time Offset - ê°œë³„ í…Œë‘ë¦¬ -->
        <div class="col-auto" style="margin-left: 8px !important;">
          <q-card flat bordered class="control-card">
            <q-card-section class="compact-control purple-1"
              style="padding: 0px 8px !important; padding-top: 0px !important; padding-bottom: 0px !important; margin: 0px !important; min-height: auto !important; height: auto !important; line-height: 1 !important; vertical-align: top !important;">
              <div class="row q-gutter-xs align-center"
                style="margin: 0px !important; padding: 0px !important; min-height: auto !important; height: auto !important;">
                <div class="col-auto position-offset-label">
                  <div class="text-subtitle2 text-weight-bold text-primary text-center">
                    Time<br>Offset
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="inputs[3]" @input="(val: string) => onInputChange(3, val)" dense outlined
                    type="number" step="0.01" label="Time"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
                <div class="col-auto">
                  <div class="vertical-button-group">
                    <div class="vertical-buttons">
                      <q-btn icon="add" size="sm" color="primary" dense flat @click="increment(3)" />
                      <q-btn icon="remove" size="sm" color="primary" dense flat @click="decrement(3)" />
                    </div>
                    <q-btn icon="refresh" size="sm" color="grey-7" dense flat @click="reset(3)" />
                  </div>
                </div>
                <div class="col-auto">
                  <q-input v-model="outputs[3]" dense outlined readonly label="Result"
                    style="width: 84px !important; min-width: 84px !important; max-width: 84px !important;" />
                </div>
                <div class="col-auto">
                  <q-input v-model="formattedCalTime" dense outlined readonly label="Cal Time"
                    style="width: 190px !important; min-width: 190px !important; max-width: 190px !important;" />
                </div>
              </div>
            </q-card-section>
          </q-card>
        </div>
      </div>

      <!-- 2í–‰: Main Content -->
      <div class="row q-col-gutter-md">
        <!-- 1ë²ˆ ì˜ì—­: ì°¨íŠ¸ê°€ ë“¤ì–´ê°ˆ ë„¤ëª¨ë‚œ ì¹¸ -->
        <div class="col-12 col-md-4">
          <q-card class="control-section">
            <q-card-section>
              <div class="text-subtitle1 text-weight-bold text-primary">Position View</div>
              <div class="chart-area" ref="chartRef"></div>
            </q-card-section>
          </q-card>
        </div>

        <!-- 2ë²ˆ ì˜ì—­: ê³„ì‚° ì •ë³´ í‘œì‹œ ì˜ì—­ ìˆ˜ì • -->
        <div class="col-12 col-md-4">
          <q-card class="control-section">
            <q-card-section>
              <div class="text-subtitle1 text-weight-bold text-primary">ìœ„ì„± ì¶”ì  ìƒíƒœ</div>

              <!-- âœ… ì¶”ì  ìƒíƒœ í‘œì‹œ -->
              <div class="info-row">
                <span class="info-label">ì¶”ì  ìƒíƒœ:</span>
                <q-chip :color="icdStore.ephemerisTrackingStateInfo.displayColor" text-color="white"
                  :label="icdStore.ephemerisTrackingStateInfo.displayLabel" size="sm" class="tracking-status-chip" />
              </div>

              <div class="ephemeris-form">
                <div class="form-row">
                  <!-- âœ… ì •ì§€ê¶¤ë„ ì •ë³´ í‘œì‹œ -->
                  <div v-if="selectedScheduleInfo.isGeostationary" class="schedule-info q-mt-md">
                    <div class="text-subtitle2 text-weight-bold text-primary q-mb-sm">
                      ì •ì§€ê¶¤ë„ ìœ„ì„± ì •ë³´
                    </div>

                    <div class="info-row">
                      <span class="info-label">ìœ„ì„± ì´ë¦„/ID:</span>
                      <span class="info-value">{{ selectedScheduleInfo.satelliteName }}</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ë°©ìœ„ê°:</span>
                      <span class="info-value">{{ selectedScheduleInfo.startAzimuth.toFixed(2) }}Â°</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ê³ ë„:</span>
                      <span class="info-value">{{ selectedScheduleInfo.startElevation.toFixed(2) }}Â°</span>
                    </div>
                  </div>

                  <!-- âœ… ê¸°ì¡´ ìŠ¤ì¼€ì¤„ ì •ë³´ í‘œì‹œ (ì •ì§€ê¶¤ë„ê°€ ì•„ë‹Œ ê²½ìš°) -->
                  <div v-else-if="selectedScheduleInfo.satelliteName" class="schedule-info q-mt-md">
                    <div class="text-subtitle2 text-weight-bold text-primary q-mb-sm">
                      ì„ íƒëœ ìŠ¤ì¼€ì¤„ ì •ë³´
                    </div>

                    <div class="info-row">
                      <span class="info-label">ìœ„ì„± ì´ë¦„:</span>
                      <span class="info-value">{{ selectedScheduleInfo.satelliteName }}</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ìœ„ì„± ID:</span>
                      <span class="info-value">{{ selectedScheduleInfo.satelliteId }}</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ì‹œì‘ ì‹œê°„:</span>
                      <span class="info-value">{{
                        formatToLocalTime(selectedScheduleInfo.startTime)
                        }}</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ì¢…ë£Œ ì‹œê°„:</span>
                      <span class="info-value">{{
                        formatToLocalTime(selectedScheduleInfo.endTime)
                        }}</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ì§€ì† ì‹œê°„:</span>
                      <span class="info-value">{{ selectedScheduleInfo.duration }}</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ì‹œì‘ ë°©ìœ„ê°/ê³ ë„:</span>
                      <span class="info-value">{{ selectedScheduleInfo.startAzimuth.toFixed(2) }}Â° /
                        {{ selectedScheduleInfo.startElevation.toFixed(2) }}Â°</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ì¢…ë£Œ ë°©ìœ„ê°/ê³ ë„:</span>
                      <span class="info-value">{{ selectedScheduleInfo.endAzimuth.toFixed(2) }}Â° /
                        {{ selectedScheduleInfo.endElevation.toFixed(2) }}Â°</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ìµœëŒ€ ê³ ë„:</span>
                      <span class="info-value">{{ selectedScheduleInfo.maxElevation.toFixed(2) }}Â°</span>
                    </div>

                    <div class="info-row">
                      <span class="info-label">ë‚¨ì€ ì‹œê°„:</span>
                      <span class="info-value" :class="{
                        'text-negative': timeRemaining < 0,
                        'text-positive': timeRemaining > 0,
                        'text-grey': timeRemaining === 0,
                      }">
                        {{ formatTimeRemaining(timeRemaining) }}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            </q-card-section>
          </q-card>
        </div>

        <!-- 3ë²ˆ ì˜ì—­: TLE Data -->
        <div class="col-12 col-md-4">
          <q-card class="control-section">
            <q-card-section>
              <div class="text-subtitle1 text-weight-bold text-primary">TLE Data</div>
              <q-editor v-model="tleData.displayText" readonly flat dense class="tle-display q-mt-sm" :toolbar="[]"
                :definitions="{
                  bold: undefined,
                  italic: undefined,
                  strike: undefined,
                  underline: undefined,
                }" content-class="tle-content" />
              <div class="button-group q-mt-md">
                <q-btn color="primary" label="Text" @click="openTLEModal" class="q-mr-sm" />
                <q-btn color="primary" label="Select Schedule" @click="openScheduleModal" class="q-mr-sm" />
                <!-- âœ… ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ì¶”ê°€ -->
                <q-btn color="secondary" label="Download" icon="download" @click="downloadRealtimeData"
                  class="q-mr-sm" />
              </div>
              <!-- ë²„íŠ¼ ê·¸ë£¹ ì¶”ê°€ -->
              <div class="button-group q-mt-md">
                <q-btn color="positive" label="Go" @click="handleEphemerisCommand" class="q-mr-sm" />
                <q-btn color="warning" label="Stop" @click="handleStopCommand" class="q-mr-sm" />
                <q-btn color="negative" label="Stow" @click="handleStowCommand" class="q-mr-sm" />
              </div>
              <!-- ìƒˆë¡œìš´ ë²„íŠ¼ ê·¸ë£¹ ì¶”ê°€ -->
              <div class="button-group q-mt-md">
                <q-btn color="info" label="Axis Calculator" icon="calculate" @click="openAxisTransformCalculator"
                  class="q-mr-sm" />
                <q-btn color="secondary" label="ì´ë¡ ì¹˜ ë‹¤ìš´ë¡œë“œ" icon="download" @click="exportAllMstDataToCsv"
                  :loading="isExportingCsv" />
              </div>
            </q-card-section>
          </q-card>
        </div>
      </div>
    </div>
  </div>

  <!-- TLE ì…ë ¥ ëª¨ë‹¬ -->
  <q-dialog v-model="showTLEModal" persistent>
    <q-card class="q-pa-md" style="width: 700px; max-width: 95vw">
      <q-card-section class="bg-primary text-white">
        <div class="text-h6">TLE ì…ë ¥</div>
      </q-card-section>

      <q-card-section class="q-pa-md">
        <div class="text-body2 q-mb-md">
          2ì¤„ ë˜ëŠ” 3ì¤„ í˜•ì‹ì˜ TLE ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”. 3ì¤„ í˜•ì‹ì¸ ê²½ìš° ì²« ë²ˆì§¸ ì¤„ì€ ìœ„ì„± ì´ë¦„ìœ¼ë¡œ
          ì²˜ë¦¬ë©ë‹ˆë‹¤.
          <br />ì˜ˆì‹œ:
          <pre class="q-mt-sm q-pa-sm bg-grey-9 text-white rounded-borders"
            style="font-size: 0.8rem; white-space: pre-wrap">
ISS (ZARYA)
1 25544U 98067A   24054.51736111  .00020125  00000+0  36182-3 0  9999
2 25544  51.6416 142.1133 0003324 324.9821 218.2594 15.49780383446574</pre>
        </div>
        <div class="tle-input-container q-mb-md">
          <q-input v-model="tempTLEData.tleText" type="textarea" filled autogrow class="tle-textarea full-width"
            style="min-height: 200px; font-family: monospace; font-size: 0.9rem" placeholder="TLE ë°ì´í„°ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”..."
            :input-style="'white-space: pre;'" spellcheck="false" autofocus :error="tleError !== null"
            :error-message="tleError || undefined" @keydown.ctrl.enter="addTLEData" />
        </div>
      </q-card-section>

      <q-card-actions align="right" class="q-px-md q-pb-md">
        <q-btn flat label="ì¶”ê°€" color="primary" @click="addTLEData" :loading="isProcessingTLE"
          :disable="!tempTLEData.tleText.trim()" />
        <q-btn flat label="ë‹«ê¸°" color="primary" v-close-popup class="q-ml-sm" :disable="isProcessingTLE" />
      </q-card-actions>
    </q-card>
  </q-dialog>

  <!-- ìŠ¤ì¼€ì¤„ ì„ íƒ ëª¨ë‹¬ -->
  <q-dialog v-model="showScheduleModal" persistent maximized>
    <q-card class="q-pa-md" style="width: 1200px; max-width: 98vw; max-height: 70vh">
      <q-card-section class="bg-primary text-white">
        <div class="text-h6">Select Schedule</div>
      </q-card-section>

      <q-card-section class="q-pa-md" style="max-height: 50vh; overflow: auto">
        <q-table :rows="scheduleData" :columns="scheduleColumns" row-key="No" :loading="loadingSchedule"
          :pagination="{ rowsPerPage: 10 }" selection="single" v-model:selected="selectedSchedule"
          class="bg-grey-9 text-white" dark flat bordered>
          <template v-slot:loading>
            <q-inner-loading showing color="primary">
              <q-spinner size="50px" color="primary" />
            </q-inner-loading>
          </template>
        </q-table>
      </q-card-section>

      <q-card-actions align="right">
        <q-btn flat label="Select" color="primary" @click="selectSchedule" :disable="selectedSchedule.length === 0" />
        <q-btn flat label="Close" color="primary" v-close-popup class="q-ml-sm" />
      </q-card-actions>
    </q-card>
  </q-dialog>
</template>
<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed, watch } from 'vue'
import { date } from 'quasar'

import type { QTableProps } from 'quasar'
import { useICDStore } from '../../stores/icd/icdStore'
import * as echarts from 'echarts'
import type { ECharts } from 'echarts'
import { useEphemerisTrackModeStore } from '@/stores'
import { formatToLocalTime, formatTimeRemaining, getCalTimeTimestamp } from '../../utils/times'
// ì¸í„°í˜ì´ìŠ¤ ì •ì˜ - ì„œë¹„ìŠ¤ì˜ íƒ€ì…ê³¼ ë™ì¼í•˜ê²Œ ì‚¬ìš©
import {
  ephemerisTrackService,
  type ScheduleItem,
  type RealtimeTrackingDataItem,
} from '../../services/mode/ephemerisTrackService'
import { openPopup } from '../../utils/windowUtils'
// âœ… ìŠ¤í† ì–´ ì—°ë™ ì¶”ê°€
const ephemerisStore = useEphemerisTrackModeStore()

// ECharts ë°ì´í„° í¬ì¸íŠ¸ íƒ€ì… ì •ì˜
interface EChartsScatterParam {
  value: [number, number]
  dataIndex: number
  seriesIndex: number
  seriesName: string
  name: string
  color: string
  borderColor: string
  dimensionNames: string[]
  encode: Record<string, number[]>
  marker: string
  data: [number, number]
  dimensionIndex: number
}

// ìŠ¤í† ì–´ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
const icdStore = useICDStore()

// ì°¨íŠ¸ ë°ì´í„°ìš© ì¸í„°í˜ì´ìŠ¤
interface TrajectoryPoint {
  Time: string
  Azimuth: number
  Elevation: number
  [key: string]: string | number | boolean | null | undefined
}

// ì°¨íŠ¸ ê´€ë ¨ ë³€ìˆ˜
const chartRef = ref<HTMLElement | null>(null)
let chart: ECharts | null = null
let updateTimer: number | null = null

// TLE Data ìŠ¤í† ì–´ì—ì„œ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
const tleData = computed(() => ephemerisStore.tleDisplayData)
// Ephemeris Designation ëª¨ë“œ ë°ì´í„° - í˜„ì¬ ìœ„ì¹˜ ì •ë³´ í‘œì‹œìš©
const currentPosition = ref({
  azimuth: 0,
  elevation: 0,
  train: 0,
  date: date.formatDate(new Date(), 'YYYY/MM/DD'),
  time: date.formatDate(new Date(), 'HH:mm'),
})

// âœ… ìŠ¤í† ì–´ ìƒíƒœ ì—°ë™ - íƒ­ ì´ë™ ì‹œì—ë„ ë°ì´í„° ìœ ì§€
const showScheduleModal = ref(false)

const scheduleData = computed(() => ephemerisStore.masterData)
const selectedSchedule = ref<ScheduleItem[]>([])
const loadingSchedule = ref(false)

// TLE ëª¨ë‹¬ ê´€ë ¨ ìƒíƒœ
const showTLEModal = ref(false)
const tempTLEData = ref({
  tleText: '', // ì „ì²´ TLE í…ìŠ¤íŠ¸ë¥¼ ì €ì¥
})

// TLE ê´€ë ¨ ìƒíƒœ
const tleError = ref<string | null>(null)
const isProcessingTLE = ref(false)

// CSV ë‚´ë³´ë‚´ê¸° ê´€ë ¨ ìƒíƒœ
const isExportingCsv = ref(false)

// QTable ì»¬ëŸ¼ íƒ€ì… ì •ì˜
type QTableColumn = NonNullable<QTableProps['columns']>[0]

// ìŠ¤ì¼€ì¤„ í…Œì´ë¸” ì»¬ëŸ¼ ì •ì˜
const scheduleColumns: QTableColumn[] = [
  { name: 'No', label: 'No', field: 'No', align: 'left', sortable: true },
  {
    name: 'SatelliteName',
    label: 'ìœ„ì„± ì´ë¦„',
    field: 'SatelliteName',
    align: 'left',
    sortable: true,

    format: (val, row) => val || row.SatelliteID || 'ì´ë¦„ ì—†ìŒ',
  },
  {
    name: 'StartTime',
    label: 'ì‹œì‘ ì‹œê°„',
    field: 'StartTime',
    align: 'left',
    sortable: true,
    format: (val) => formatToLocalTime(val),
  },
  {
    name: 'EndTime',
    label: 'ì¢…ë£Œ ì‹œê°„',
    field: 'EndTime',
    align: 'left',
    sortable: true,
    format: (val) => formatToLocalTime(val),
  },
  { name: 'Duration', label: 'ì§€ì† ì‹œê°„', field: 'Duration', align: 'left', sortable: true },
  {
    name: 'MaxElevation',
    label: 'ìµœëŒ€ ê³ ë„ (Â°)',
    field: 'MaxElevation',
    align: 'left',
    sortable: true,
  },
]

// âœ… ìƒˆë¡œìš´ ì½”ë“œë¡œ êµì²´:
// ìŠ¤í† ì–´ì—ì„œ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
const inputs = ref<string[]>(['0.00', '0.00', '0.00', '0.00'])
// âœ… outputs ê³„ì‚°ëœ ì†ì„± ìˆ˜ì • - Time Result ë¶„ë¦¬
const outputs = computed(() => [
  ephemerisStore.offsetValues.azimuth,
  ephemerisStore.offsetValues.elevation,
  ephemerisStore.offsetValues.train,
  ephemerisStore.offsetValues.timeResult, // âœ… ë³„ë„ ê´€ë¦¬ë˜ëŠ” Result ê°’
])
// Quasar ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
import { useQuasar } from 'quasar'

const $q = useQuasar()

// âœ… ìŠ¤í† ì–´ì—ì„œ ì„ íƒëœ ìŠ¤ì¼€ì¤„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° - íƒ­ ì´ë™ ì‹œì—ë„ ìœ ì§€
const selectedScheduleInfo = computed(() => {
  // âœ… ì •ì§€ê¶¤ë„ ê°ë„ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì •ì§€ê¶¤ë„ ì •ë³´ í‘œì‹œ
  if (ephemerisStore.geostationaryAngles.isSet) {
    // TLE ë¼ì¸ì—ì„œ ìœ„ì„± ID ì¶”ì¶œ
    const tleLine1 = ephemerisStore.geostationaryAngles.tleLine1 || ''
    const satelliteId = tleLine1.length >= 7 ? tleLine1.substring(2, 7).trim() : 'N/A'

    // ìœ„ì„± ì´ë¦„ê³¼ ID êµ¬ë¶„
    const satelliteName = ephemerisStore.geostationaryAngles.satelliteName || ''

    // í‘œì‹œìš© ì´ë¦„ ìƒì„±: 3ì¤„ TLEë©´ "ì´ë¦„/ID", 2ì¤„ TLEë©´ "ID"ë§Œ
    const displayName = satelliteName && satelliteName !== satelliteId
      ? `${satelliteName}/${satelliteId}`
      : satelliteId

    return {
      passId: 0,
      satelliteName: displayName,
      satelliteId: satelliteId,
      originalSatelliteName: satelliteName, // ì›ë³¸ ì´ë¦„ ë³´ì¡´
      startTime: '',
      endTime: '',
      duration: '',
      maxElevation: ephemerisStore.geostationaryAngles.elevation,
      startTimeMs: 0,
      timeRemaining: 0,
      startAzimuth: ephemerisStore.geostationaryAngles.azimuth,
      endAzimuth: ephemerisStore.geostationaryAngles.azimuth,
      startElevation: ephemerisStore.geostationaryAngles.elevation,
      endElevation: ephemerisStore.geostationaryAngles.elevation,
      isGeostationary: true, // âœ… ì •ì§€ê¶¤ë„ êµ¬ë¶„ í”Œë˜ê·¸
    }
  }

  // ê¸°ì¡´ ìŠ¤ì¼€ì¤„ ì •ë³´ ë¡œì§
  const selected = ephemerisStore.selectedSchedule
  if (selected) {
    return {
      passId: selected.No,
      satelliteName: selected.SatelliteName || selected.SatelliteID || 'ì•Œ ìˆ˜ ì—†ìŒ',
      satelliteId: selected.SatelliteID || 'N/A',
      startTime: selected.StartTime,
      endTime: selected.EndTime,
      duration: selected.Duration,
      maxElevation: typeof selected.MaxElevation === 'number' ? selected.MaxElevation : 0,
      startTimeMs: new Date(selected.StartTime).getTime(),
      timeRemaining: 0,
      startAzimuth: typeof selected.StartAzimuth === 'number' ? selected.StartAzimuth : 0,
      endAzimuth: typeof selected.EndAzimuth === 'number' ? selected.EndAzimuth : 0,
      startElevation: typeof selected.StartElevation === 'number' ? selected.StartElevation : 0,
      endElevation: typeof selected.EndElevation === 'number' ? selected.EndElevation : 0,
      isGeostationary: false,
    }
  }

  return {
    passId: 0,
    satelliteName: '',
    satelliteId: '',
    startTime: '',
    endTime: '',
    duration: '',
    maxElevation: 0,
    startTimeMs: 0,
    timeRemaining: 0,
    startAzimuth: 0,
    endAzimuth: 0,
    startElevation: 0,
    endElevation: 0,
    isGeostationary: false,
  }
})

// âœ… ì¶”ì  ìƒíƒœ ë³€ê²½ ê°ì§€ ë° ê²½ë¡œ ì´ˆê¸°í™”
watch(() => icdStore.ephemerisTrackingState, (newState, oldState) => {
  console.log('ğŸ”„ ì¶”ì  ìƒíƒœ ë³€ê²½:', oldState, 'â†’', newState)

  // ì¶”ì  ì‹œì‘ ë˜ëŠ” ì™„ë£Œ ì‹œ ê²½ë¡œ ì´ˆê¸°í™”
  if (newState === 'TRACKING' || newState === 'COMPLETED' || newState === 'IDLE') {
    // âœ… í˜„ì¬ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²½ë¡œ ì´ˆê¸°í™” (0ë„ì—ì„œ ì‹œì‘í•˜ëŠ” ë¬¸ì œ í•´ê²°)
    const currentAzimuth = parseFloat(icdStore.azimuthAngle) || 0
    const currentElevation = parseFloat(icdStore.elevationAngle) || 0

    ephemerisStore.clearTrackingPath(currentAzimuth, currentElevation)
    console.log('ğŸ§¹ ì¶”ì  ê²½ë¡œ ì´ˆê¸°í™” ì™„ë£Œ - í˜„ì¬ ìœ„ì¹˜ ê¸°ì¤€:', {
      azimuth: currentAzimuth,
      elevation: currentElevation
    })
  }
})
// âœ… ê°œì„ ëœ RealtimeTrackingDataItem íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” CSV ë‹¤ìš´ë¡œë“œ í•¨ìˆ˜
const downloadCSVWithTransformations = (data: RealtimeTrackingDataItem[]) => {
  // ì•ˆì „í•œ ìˆ«ì í¬ë§·íŒ… í•¨ìˆ˜
  const safeToFixed = (value: number | null | undefined, digits: number = 4): string => {
    if (value === null || value === undefined || isNaN(Number(value))) {
      return '0.0000'
    }
    return Number(value).toFixed(digits)
  }

  // CSV í—¤ë” ì •ì˜ - ì›ë³¸/ì¶•ë³€í™˜/ìµœì¢… ë°ì´í„° í¬í•¨
  const headers = [
    'Index', 'TheoreticalIndex', 'Timestamp', 'PassId', 'ElapsedTime(s)',

    // ì›ë³¸ ë°ì´í„° (ë³€í™˜ ì „)
    'OriginalAzimuth(Â°)', 'OriginalElevation(Â°)', 'OriginalRange(km)', 'OriginalAltitude(km)',

    // ì¶•ë³€í™˜ ë°ì´í„° (ê¸°ìš¸ê¸° ë³€í™˜ ì ìš©)
    'AxisTransformedAzimuth(Â°)', 'AxisTransformedElevation(Â°)', 'AxisTransformedRange(km)', 'AxisTransformedAltitude(km)',

    // ìµœì¢… ë³€í™˜ ë°ì´í„° (Â±270ë„ ì œí•œ ì ìš©)
    'FinalTransformedAzimuth(Â°)', 'FinalTransformedElevation(Â°)', 'FinalTransformedRange(km)', 'FinalTransformedAltitude(km)',

    // ëª…ë ¹ ë° ì‹¤ì œ ì¶”ì  ë°ì´í„°
    'CmdAzimuth(Â°)', 'CmdElevation(Â°)', 'ActualAzimuth(Â°)', 'ActualElevation(Â°)',
    'TrackingAzimuthTime(s)', 'TrackingCMDAzimuth(Â°)', 'TrackingActualAzimuth(Â°)',
    'TrackingElevationTime(s)', 'TrackingCMDElevation(Â°)', 'TrackingActualElevation(Â°)',
    'TrackingTrainTime(s)', 'TrackingCMDTrain(Â°)', 'TrackingActualTrain(Â°)',

    // ì˜¤ì°¨ ë¶„ì„
    'AzimuthError(Â°)', 'ElevationError(Â°)',
    'OriginalToAxisTransformationError(Â°)', 'AxisToFinalTransformationError(Â°)', 'TotalTransformationError(Â°)',

    // ì •í™•ë„ ë¶„ì„ (ìƒˆë¡œ ì¶”ê°€ëœ í•„ë“œë“¤)
    'ì‹œê°„ì •í™•ë„(s)', 'Az_CMDì •í™•ë„(Â°)', 'Az_Actì •í™•ë„(Â°)', 'Az_ìµœì¢…ì •í™•ë„(Â°)',
    'El_CMDì •í™•ë„(Â°)', 'El_Actì •í™•ë„(Â°)', 'El_ìµœì¢…ì •í™•ë„(Â°)',

    // ë³€í™˜ ì •ë³´
    'TrainAngle(Â°)', 'TransformationType', 'HasTransformation', 'InterpolationMethod', 'InterpolationAccuracy'
  ]

  // CSV ë°ì´í„° ìƒì„± (ì•ˆì „í•œ ì²˜ë¦¬ ì ìš©)
  const csvContent = [
    headers.join(','),
    ...data.map((item) =>
      [
        item.index || 0,
        item.theoreticalIndex || 0,  // âœ… ì´ë¡ ì¹˜ ë°ì´í„° ì¸ë±ìŠ¤ ì¶”ê°€
        `"${item.timestamp ? formatToLocalTime(item.timestamp) : new Date().toISOString()}"`,
        item.passId || 0,
        safeToFixed(item.elapsedTimeSeconds, 3),

        // ì›ë³¸ ë°ì´í„° (ë³€í™˜ ì „)
        safeToFixed(item.originalAzimuth, 6),
        safeToFixed(item.originalElevation, 6),
        safeToFixed(item.originalRange, 6),
        safeToFixed(item.originalAltitude, 6),

        // ì¶•ë³€í™˜ ë°ì´í„° (ê¸°ìš¸ê¸° ë³€í™˜ ì ìš©)
        safeToFixed(item.axisTransformedAzimuth, 6),
        safeToFixed(item.axisTransformedElevation, 6),
        safeToFixed(item.axisTransformedRange, 6),
        safeToFixed(item.axisTransformedAltitude, 6),

        // ìµœì¢… ë³€í™˜ ë°ì´í„° (Â±270ë„ ì œí•œ ì ìš©)
        safeToFixed(item.finalTransformedAzimuth, 6),
        safeToFixed(item.finalTransformedElevation, 6),
        safeToFixed(item.finalTransformedRange, 6),
        safeToFixed(item.finalTransformedAltitude, 6),

        // ëª…ë ¹ ë° ì‹¤ì œ ì¶”ì  ë°ì´í„°
        safeToFixed(item.cmdAz, 6),
        safeToFixed(item.cmdEl, 6),
        safeToFixed(item.actualAz, 6),
        safeToFixed(item.actualEl, 6),
        safeToFixed(item.trackingAzimuthTime, 2),
        safeToFixed(item.trackingCMDAzimuthAngle, 6),
        safeToFixed(item.trackingActualAzimuthAngle, 6),
        safeToFixed(item.trackingElevationTime, 2),
        safeToFixed(item.trackingCMDElevationAngle, 6),
        safeToFixed(item.trackingActualElevationAngle, 6),
        safeToFixed(item.trackingTrainTime, 2),
        safeToFixed(item.trackingCMDTrainAngle, 6),
        safeToFixed(item.trackingActualTrainAngle, 6),

        // ì˜¤ì°¨ ë¶„ì„
        safeToFixed(item.azimuthError, 6),
        safeToFixed(item.elevationError, 6),
        safeToFixed(item.originalToAxisTransformationError, 6),
        safeToFixed(item.axisToFinalTransformationError, 6),
        safeToFixed(item.totalTransformationError, 6),

        // ì •í™•ë„ ë¶„ì„ (ìƒˆë¡œ ì¶”ê°€ëœ í•„ë“œë“¤)
        safeToFixed(item.timeAccuracy, 6),
        safeToFixed(item.azCmdAccuracy, 6),
        safeToFixed(item.azActAccuracy, 6),
        safeToFixed(item.azFinalAccuracy, 6),
        safeToFixed(item.elCmdAccuracy, 6),
        safeToFixed(item.elActAccuracy, 6),
        safeToFixed(item.elFinalAccuracy, 6),

        // ë³€í™˜ ì •ë³´
        safeToFixed(item.trainAngle, 6),
        `"${item.transformationType || 'none'}"`,
        item.hasTransformation ? 'true' : 'false',
        `"${item.interpolationMethod || 'linear'}"`,
        safeToFixed(item.interpolationAccuracy, 6)
      ].join(','),
    ),
  ].join('\n')

  // BOM ì¶”ê°€ (í•œê¸€ ê¹¨ì§ ë°©ì§€)
  const BOM = '\uFEFF'
  const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' })

  // íŒŒì¼ëª… ìƒì„± (í˜„ì¬ ì‹œê°„ í¬í•¨)
  const now = new Date()
  const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19)
  const filename = `realtime_tracking_data_with_transformations_${timestamp}.csv`

  // ë‹¤ìš´ë¡œë“œ ì‹¤í–‰
  const link = document.createElement('a')
  const url = URL.createObjectURL(blob)
  link.setAttribute('href', url)
  link.setAttribute('download', filename)
  link.style.visibility = 'hidden'
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}

const downloadRealtimeData = async () => {
  try {
    // Loading ëŒ€ì‹  notifyë¡œ ì‹œì‘ ì•Œë¦¼
    $q.notify({
      type: 'info',
      message: 'ì‹¤ì‹œê°„ ì¶”ì  ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ê³  ìˆìŠµë‹ˆë‹¤...',
      timeout: 2000,
    })

    // âœ… ê¸°ì¡´ API í˜¸ì¶œ - generateRealtimeTrackingCsvì™€ ì—°ê³„
    const response = await ephemerisTrackService.fetchRealtimeTrackingData()

    if (response.data && response.data.length > 0) {
      // âœ… í´ë¼ì´ì–¸íŠ¸ì—ì„œ CSV ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
      downloadCSVWithTransformations(response.data)

      $q.notify({
        type: 'positive',
        message: `${response.totalCount || 0}ê°œì˜ ì‹¤ì‹œê°„ ì¶”ì  ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œí–ˆìŠµë‹ˆë‹¤`,
        timeout: 5000,
      })

      console.log('ì‹¤ì‹œê°„ ì¶”ì  ë°ì´í„° ë‹¤ìš´ë¡œë“œ ê²°ê³¼:', response)
    } else {
      $q.notify({
        type: 'warning',
        message: 'ë‹¤ìš´ë¡œë“œí•  ì‹¤ì‹œê°„ ì¶”ì  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤',
        timeout: 3000,
      })
    }
  } catch (error) {
    console.error('ì‹¤ì‹œê°„ ì¶”ì  ë°ì´í„° ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error)
    $q.notify({
      type: 'negative',
      message: 'ì‹¤ì‹œê°„ ì¶”ì  ë°ì´í„° ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
      timeout: 5000,
    })
  }
}


// ë‚¨ì€ ì‹œê°„ ê³„ì‚°ì„ ìœ„í•œ ìƒíƒœ
const timeRemaining = ref(0)
let timeUpdateTimer: number | null = null

// âœ… ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
// âœ… TypeScript ì•ˆì „í•œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
class PerformanceMonitor {
  private frameTimings: number[] = []
  private gcDetectionThreshold = 50
  private lastFrameTime = 0
  private stats = {
    totalFrames: 0,
    gcSuspectedFrames: 0,
    averageFrameTime: 0,
    maxFrameTime: 0,
    memorySnapshots: [] as Array<{
      timestamp: number
      used: string
      total: string
      frameCount: number
    }>,
  }

  measureFrame(callback: () => void) {
    const startTime = performance.now()

    callback()

    const endTime = performance.now()
    const frameTime = endTime - startTime

    this.frameTimings.push(frameTime)
    if (this.frameTimings.length > 100) {
      this.frameTimings.shift()
    }

    this.stats.totalFrames++
    this.stats.maxFrameTime = Math.max(this.stats.maxFrameTime, frameTime)
    this.stats.averageFrameTime =
      this.frameTimings.reduce((a, b) => a + b, 0) / this.frameTimings.length

    if (frameTime > this.gcDetectionThreshold) {
      this.stats.gcSuspectedFrames++
      console.warn(`ğŸŒ ëŠë¦° í”„ë ˆì„ ê°ì§€: ${frameTime.toFixed(2)}ms`, {
        ë©”ëª¨ë¦¬: this.getMemoryInfo(),
        í”„ë ˆì„ë¹„ìœ¨: `${this.stats.gcSuspectedFrames}/${this.stats.totalFrames}`,
        í‰ê· í”„ë ˆì„ì‹œê°„: this.stats.averageFrameTime.toFixed(2) + 'ms',
      })
    }

    if (this.stats.totalFrames % 100 === 0) {
      this.takeMemorySnapshot()
    }
  }

  private getMemoryInfo(): { used: string; total: string } | null {
    // âœ… performance.memory íƒ€ì… ì²´í¬
    if ('memory' in performance && performance.memory) {
      const memory = performance.memory as {
        usedJSHeapSize: number
        totalJSHeapSize: number
        jsHeapSizeLimit: number
      }

      return {
        used: Math.round(memory.usedJSHeapSize / 1024 / 1024) + 'MB',
        total: Math.round(memory.totalJSHeapSize / 1024 / 1024) + 'MB',
      }
    }
    return null
  }

  private takeMemorySnapshot() {
    const memInfo = this.getMemoryInfo()
    if (memInfo) {
      this.stats.memorySnapshots.push({
        timestamp: Date.now(),
        ...memInfo,
        frameCount: this.stats.totalFrames,
      })

      if (this.stats.memorySnapshots.length > 10) {
        this.stats.memorySnapshots.shift()
      }

      if (this.stats.memorySnapshots.length >= 3) {
        const recent = this.stats.memorySnapshots.slice(-3)
        const memoryTrend = recent.map((s) => parseInt(s.used))
        const isIncreasing = memoryTrend.every(
          (val, i) => i === 0 || val >= (memoryTrend[i - 1] ?? 0),
        )

        if (isIncreasing) {
          console.warn('ğŸ“ˆ ë©”ëª¨ë¦¬ ì§€ì† ì¦ê°€ ê°ì§€:', memoryTrend)
        }
      }
    }
  }

  getReport() {
    return {
      ...this.stats,
      gcSuspectedRatio:
        ((this.stats.gcSuspectedFrames / this.stats.totalFrames) * 100).toFixed(2) + '%',
    }
  }
}

const perfMonitor = new PerformanceMonitor()

// âœ… ê°ì²´ í’€ë§ìœ¼ë¡œ GC ì••ë°• ìµœì†Œí™”
// âœ… TypeScript ì•ˆì „í•œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ í’€
class ChartUpdatePool {
  private positionData: [number, number][] = [[0, 0]]
  private trackingData: [number, number][] = []
  private updateOption: {
    series: Array<{ data?: [number, number][] }>
  }

  constructor() {
    this.updateOption = {
      series: [{ data: this.positionData }, {}, { data: this.trackingData }, {}],
    }
  }

  updatePosition(elevation: number, azimuth: number) {
    // âœ… ë°°ì—´ ì¡´ì¬ í™•ì¸
    if (this.positionData.length > 0 && this.positionData[0]) {
      this.positionData[0][0] = elevation
      this.positionData[0][1] = azimuth
    } else {
      this.positionData = [[elevation, azimuth]]
      // ì‹œë¦¬ì¦ˆ ë°ì´í„° ì°¸ì¡° ì—…ë°ì´íŠ¸
      if (this.updateOption.series[0]) {
        this.updateOption.series[0].data = this.positionData
      }
    }
    return this.updateOption
  }

  updateTrackingPath(newPath: [number, number][]) {
    // âœ… ì•ˆì „í•œ ë°°ì—´ ì—…ë°ì´íŠ¸
    this.trackingData.length = 0
    if (Array.isArray(newPath)) {
      this.trackingData.push(...newPath)
    }
    return this.updateOption
  }
}

const chartPool = new ChartUpdatePool()

// âœ… ìµœì í™”ëœ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
// âœ… ì•ˆì „í•œ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
const updateChart = () => {
  if (!chart) {
    console.error('ì°¨íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.')
    return
  }

  perfMonitor.measureFrame(() => {
    try {
      // âœ… ì¶”ì  ìƒíƒœì— ë”°ë¼ ë‹¤ë¥¸ ë°ì´í„° ì†ŒìŠ¤ ì‚¬ìš©
      const isTrackingActive = icdStore.ephemerisTrackingState === "TRACKING" || icdStore.passScheduleStatusInfo.isActive

      const azimuth = isTrackingActive
        ? parseFloat(icdStore.trackingActualAzimuthAngle) || 0
        : parseFloat(icdStore.azimuthAngle) || 0
      const elevation = isTrackingActive
        ? parseFloat(icdStore.trackingActualElevationAngle) || 0
        : parseFloat(icdStore.elevationAngle) || 0

      const normalizedAz = azimuth < 0 ? azimuth + 360 : azimuth
      const normalizedEl = Math.max(0, Math.min(90, elevation))

      // âœ… ì•ˆì „í•œ ì†ì„± ì—…ë°ì´íŠ¸ (ì›ë³¸ ê°’ í‘œì‹œë¡œ ì¼ê´€ì„± ìœ ì§€)
      if (currentPosition.value) {
        currentPosition.value.azimuth = azimuth  // ì›ë³¸ ê°’ (-180.14Â°)
        currentPosition.value.elevation = elevation
        currentPosition.value.date = date.formatDate(new Date(), 'YYYY/MM/DD')
        currentPosition.value.time = date.formatDate(new Date(), 'HH:mm:ss')
      }

      // âœ… ì•ˆì „í•œ ìƒíƒœ ì²´í¬ (ì‹¤ì œ ì¶”ì  ìƒíƒœ í™•ì¸)
      if (icdStore.ephemerisTrackingState === "TRACKING") {
        void ephemerisStore.updateTrackingPath(azimuth, elevation)
      }

      // âœ… ì•ˆì „í•œ ì°¨íŠ¸ ì˜µì…˜ ì—…ë°ì´íŠ¸
      const option = chartPool.updatePosition(normalizedEl, normalizedAz)
      if (ephemerisStore.trackingPath?.sampledPath) {
        chartPool.updateTrackingPath(ephemerisStore.trackingPath.sampledPath as [number, number][])
      }

      // âœ… ì°¨íŠ¸ê°€ ì—¬ì „íˆ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
      if (chart && !chart.isDisposed()) {
        chart.setOption(option, false, true)
      }
    } catch (error) {
      console.error('ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error)
    }
  })
}
// âœ… ì°¨íŠ¸ ì´ˆê¸°í™” í•¨ìˆ˜ ìˆ˜ì •
const initChart = () => {
  if (!chartRef.value) return

  // ê¸°ì¡´ ì°¨íŠ¸ ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆìœ¼ë©´ ì œê±°
  if (chart) {
    chart.dispose()
  }

  // ì°¨íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
  chart = echarts.init(chartRef.value)
  console.log('ì°¨íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ë¨')

  // ì°¨íŠ¸ ì˜µì…˜ ì„¤ì •
  const option = {
    backgroundColor: 'transparent',
    grid: {
      containLabel: true,
    },
    polar: {
      radius: ['0%', '80%'],
      center: ['50%', '50%'],
    },
    angleAxis: {
      type: 'value',
      startAngle: 90,
      clockwise: true,
      min: 0,
      max: 360,
      animation: false, // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”
      axisLine: {
        show: true,
        lineStyle: {
          color: '#555',
        },
      },
      axisTick: {
        show: true,
        interval: 30,
        lineStyle: {
          color: '#555',
        },
      },
      axisLabel: {
        interval: 30,
        formatter: function (value: number) {
          if (value === 0) return 'N (0Â°)'
          if (value === 90) return 'E (90Â°)'
          if (value === 180) return 'S (180Â°)'
          if (value === 270) return 'W (270Â°)'
          if (value === 45) return 'NE (45Â°)'
          if (value === 135) return 'SE (135Â°)'
          if (value === 225) return 'SW (225Â°)'
          if (value === 315) return 'NW (315Â°)'
          if (value % 30 === 0) return value + 'Â°'
          return ''
        },
        color: '#999',
        fontSize: 10,
        distance: 10,
      },
      splitLine: {
        show: true,
        interval: 30,
        lineStyle: {
          color: '#555',
          type: 'dashed',
          width: 1,
        },
      },
    },
    radiusAxis: {
      type: 'value',
      min: 0,
      max: 90,
      inverse: true,
      animation: false, // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”
      axisLine: {
        show: false,
      },
      axisTick: {
        show: false,
      },
      axisLabel: {
        formatter: '{value}Â°',
        color: '#999',
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: '#555',
          type: 'dashed',
        },
      },
    },
    series: [
      {
        name: 'ì‹¤ì‹œê°„ ì¶”ì  ìœ„ì¹˜',
        type: 'scatter',
        coordinateSystem: 'polar',
        symbol: 'circle',
        symbolSize: 15,
        animation: false, // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”
        itemStyle: {
          color: '#ff5722',
        },
        data: [[0, 0]],
        emphasis: {
          itemStyle: {
            color: '#ff9800',
            borderColor: '#fff',
            borderWidth: 2,
          },
        },
        label: {
          show: true,
          formatter: function (params: EChartsScatterParam) {
            // âœ… ì›ë³¸ ê°’ í‘œì‹œ (ì •ê·œí™”ëœ ê°’ì´ ì•„ë‹Œ)
            const originalAz = currentPosition.value?.azimuth || params.value[1]
            const originalEl = currentPosition.value?.elevation || params.value[0]
            return `Az: ${originalAz.toFixed(2)}Â°\nEl: ${originalEl.toFixed(2)}Â°`
          },
          position: 'top',
          distance: 5,
          color: '#fff',
          backgroundColor: 'rgba(0,0,0,0.7)',
          padding: [4, 8],
          borderRadius: 4,
          fontSize: 10,
        },
        zlevel: 3,
      },
      {
        name: 'ìœ„ì¹˜ ì„ ',
        type: 'line',
        coordinateSystem: 'polar',
        symbol: 'none',
        animation: false, // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”
        lineStyle: {
          color: '#ff5722',
          width: 2,
          type: 'dashed',
        },
        data: [
          [0, 0],
          [0, 0],
        ],
        zlevel: 2,
      },
      {
        name: 'ì‹¤ì‹œê°„ ì¶”ì  ê²½ë¡œ',
        type: 'line',
        coordinateSystem: 'polar',
        symbol: 'none',
        animation: false, // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”
        lineStyle: {
          color: '#ffffff',
          width: 2, // âœ… 3 â†’ 2ë¡œ ì¤„ì—¬ì„œ ë Œë”ë§ ë¶€í•˜ ê°ì†Œ
          opacity: 0.8,
        },
        data: [],
        zlevel: 2,
      },
      {
        name: 'ìœ„ì„± ê¶¤ì ',
        type: 'line',
        coordinateSystem: 'polar',
        symbol: 'none',
        animation: false, // âœ… ì• ë‹ˆë©”ì´ì…˜ ì™„ì „ ë¹„í™œì„±í™”
        lineStyle: {
          color: '#2196f3',
          width: 2,
        },
        data: [],
        zlevel: 1,
      },
    ],
  }

  // ì°¨íŠ¸ ì˜µì…˜ ì ìš©
  chart.setOption(option)
  console.log('ì°¨íŠ¸ ì˜µì…˜ ì ìš©ë¨')

  // ëª…ì‹œì ìœ¼ë¡œ ë¦¬ì‚¬ì´ì¦ˆ í˜¸ì¶œ
  setTimeout(() => {
    chart?.resize()
  }, 0)

  // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ì— ëŒ€ì‘
  window.addEventListener('resize', () => {
    chart?.resize()
  })
}

// âœ… ìµœì í™”ëœ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì™„ì „ êµì²´)
// âœ… íƒ€ì… ì•ˆì „í•œ ê°ì²´ ì¬ì‚¬ìš© ë³€ìˆ˜ë“¤ë¡œ ìˆ˜ì •

// âœ… ì„±ëŠ¥ ì¸¡ì • ë³€ìˆ˜ë“¤ ì¶”ê°€
/* const performanceStats = {
  updateChartTime: 0,
  trackingPathUpdateTime: 0,
  chartSetOptionTime: 0,
  totalUpdateCount: 0,
  slowUpdateCount: 0,
} */

// âœ… updateChart í•¨ìˆ˜ - ë¹„ë™ê¸° Worker í™œìš©
/* const updateChart = () => {
  if (!chart) {
    console.error('ì°¨íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.')
    return
  }

  try {
    let azimuth = 0
    let elevation = 0

    // âœ… ì¶”ì  ìƒíƒœì— ë”°ë¼ ë‹¤ë¥¸ ë°ì´í„° ì†ŒìŠ¤ ì‚¬ìš©
    const isTrackingActive = icdStore.ephemerisTrackingState === "TRACKING" || icdStore.passScheduleStatusInfo.isActive

    azimuth = isTrackingActive
      ? parseFloat(icdStore.trackingActualAzimuthAngle) || 0
      : parseFloat(icdStore.azimuthAngle) || 0
    elevation = isTrackingActive
      ? parseFloat(icdStore.trackingActualElevationAngle) || 0
      : parseFloat(icdStore.elevationAngle) || 0

    const normalizedAz = azimuth < 0 ? azimuth + 360 : azimuth
    const normalizedEl = Math.max(0, Math.min(90, elevation))

    // í˜„ì¬ ìœ„ì¹˜ ì •ë³´ ì—…ë°ì´íŠ¸ (ì›ë³¸ ê°’ í‘œì‹œ)
    currentPosition.value.azimuth = azimuth  // ì›ë³¸ ê°’ (ì •ê·œí™” ì „)
    currentPosition.value.elevation = elevation
    currentPosition.value.date = date.formatDate(new Date(), 'YYYY/MM/DD')
    currentPosition.value.time = date.formatDate(new Date(), 'HH:mm:ss')

    // âœ… ì¶”ì  ì¤‘ì¼ ë•Œ Workerë¥¼ í†µí•œ ë¹„ë™ê¸° ê²½ë¡œ ì²˜ë¦¬
    if (icdStore.ephemerisTrackingState === "TRACKING") {
      // âœ… ë¹„ë™ê¸° í˜¸ì¶œì´ì§€ë§Œ ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŒ (ì„±ëŠ¥ ìµœì í™”)
      void ephemerisStore.updateTrackingPath(azimuth, elevation)
    }

    // âœ… ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (Workerì—ì„œ ì²˜ë¦¬ëœ ê²°ê³¼ ì‚¬ìš©)
    const updateOption = {
      series: [
        {
          data: [[normalizedEl, normalizedAz]],
        },
        {},
        {
          // âœ… Workerê°€ ì²˜ë¦¬í•œ ìµœì í™”ëœ ê²½ë¡œ ë°ì´í„° ì‚¬ìš©
          data: [...ephemerisStore.trackingPath.sampledPath],
        },
        {},
      ],
    } as unknown as Parameters<typeof chart.setOption>[0]

    chart.setOption(updateOption)
  } catch (error) {
    console.error('ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error)
  }
}
 */
// ê¶¤ì  ë¼ì¸ì„ ì°¨íŠ¸ì— ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜@
const updateChartWithTrajectory = (data: TrajectoryPoint[]) => {
  if (!chart) {
    console.error('ì°¨íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.')
    return
  }

  console.log('ê¶¤ì  ë°ì´í„° ì²˜ë¦¬ ì‹œì‘:', data.length, 'ê°œì˜ í¬ì¸íŠ¸')

  try {
    const trajectoryPoints = data.map((point) => {
      const az = typeof point.Azimuth === 'number' ? point.Azimuth : 0
      const el = typeof point.Elevation === 'number' ? point.Elevation : 0

      // âœ… DashboardPageì™€ ë™ì¼í•œ ì •ê·œí™” ë°©ì‹
      const normalizedAz = az < 0 ? az + 360 : az
      const normalizedEl = Math.max(0, Math.min(90, el))

      // âœ… [elevation, azimuth] ìˆœì„œë¡œ ë°˜í™˜ (ê·¹ì¢Œí‘œê³„: [radius, angle])
      return [normalizedEl, normalizedAz]
    })

    console.log('ìƒì„±ëœ ê¶¤ì  í¬ì¸íŠ¸ ìƒ˜í”Œ:', trajectoryPoints.slice(0, 5))

    // ì°¨íŠ¸ ì˜µì…˜ ì—…ë°ì´íŠ¸ - ë„¤ ë²ˆì§¸ ì‹œë¦¬ì¦ˆ(ê¶¤ì  ë¼ì¸)ë§Œ ì—…ë°ì´íŠ¸
    const trajectoryOption = {
      series: [
        {}, // ì²« ë²ˆì§¸ ì‹œë¦¬ì¦ˆëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
        {}, // ë‘ ë²ˆì§¸ ì‹œë¦¬ì¦ˆëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
        {}, // ì„¸ ë²ˆì§¸ ì‹œë¦¬ì¦ˆëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
        {
          // ë„¤ ë²ˆì§¸ ì‹œë¦¬ì¦ˆ(ê¶¤ì  ë¼ì¸) ì—…ë°ì´íŠ¸
          data: trajectoryPoints,
        },
      ],
    } as unknown as Parameters<typeof chart.setOption>[0]

    chart.setOption(trajectoryOption)

    console.log('ì°¨íŠ¸ ì˜µì…˜ ì—…ë°ì´íŠ¸ ì™„ë£Œ')
  } catch (error) {
    console.error('ì°¨íŠ¸ ì˜µì…˜ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error)
  }
}
// âœ… ê°œì„ ëœ ì‹œê°„ ê³„ì‚° í•¨ìˆ˜ ìˆ˜ì •
const updateTimeRemaining = () => {
  if (selectedScheduleInfo.value.startTimeMs > 0) {
    try {
      const currentCalTime = getCalTimeTimestamp(icdStore.resultTimeOffsetCalTime)
      const remainingMs = selectedScheduleInfo.value.startTimeMs - currentCalTime
      timeRemaining.value = remainingMs
    } catch (error) {
      console.error('ì‹œê°„ ê³„ì‚° ì˜¤ë¥˜:', error)
      const clientTime = Date.now()
      timeRemaining.value = Math.max(0, selectedScheduleInfo.value.startTimeMs - clientTime)
    }
  }
}

// ===== ìŠ¤í† ì–´ ì—°ë™ ë©”ì„œë“œë“¤ =====

// âœ… ìŠ¤ì¼€ì¤„ ë°ì´í„° ë¡œë“œ - ìŠ¤í† ì–´ ì‚¬ìš©
const loadScheduleData = async () => {
  loadingSchedule.value = true
  try {
    await ephemerisStore.loadMasterData(true)
  } catch (error) {
    console.error('ìŠ¤ì¼€ì¤„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error)
    $q.notify({
      type: 'negative',
      message: 'ìŠ¤ì¼€ì¤„ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
    })
  } finally {
    loadingSchedule.value = false
  }
}

// âœ… ìŠ¤ì¼€ì¤„ ì„ íƒ - ìŠ¤í† ì–´ì— ì €ì¥í•˜ì—¬ íƒ­ ì´ë™ ì‹œì—ë„ ìœ ì§€
const selectSchedule = async () => {
  if (selectedSchedule.value.length === 0) return

  try {
    const selectedItem = selectedSchedule.value[0]
    if (!selectedItem) return

    // âœ… ì •ì§€ê¶¤ë„ ìƒíƒœ ì´ˆê¸°í™” (ìŠ¤ì¼€ì¤„ ì„ íƒ ì‹œ)
    ephemerisStore.resetGeostationaryAngles()

    // ìŠ¤í† ì–´ì— ì„ íƒëœ ìŠ¤ì¼€ì¤„ ì €ì¥ (íƒ­ ì´ë™ ì‹œì—ë„ ìœ ì§€ë¨)
    await ephemerisStore.selectSchedule(selectedItem)

    // ìƒì„¸ ë°ì´í„° ë¡œë“œ
    // ìŠ¤í† ì–´ì˜ detailDataëŠ” selectSchedule ë©”ì„œë“œ ë‚´ì—ì„œ ì´ë¯¸ ë¡œë“œë¨
    const detailData = ephemerisStore.detailData

    // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
    if (detailData && detailData.length > 0 && chart) {
      updateChartWithTrajectory([...detailData] as TrajectoryPoint[])
    }

    $q.notify({
      type: 'positive',
      message: `${selectedItem.SatelliteName || selectedItem.SatelliteID} ìŠ¤ì¼€ì¤„ì´ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤`,
    })

    showScheduleModal.value = false
  } catch (error) {
    console.error('ìŠ¤ì¼€ì¤„ ì„ íƒ ì‹¤íŒ¨:', error)
    $q.notify({
      type: 'negative',
      message: 'ìŠ¤ì¼€ì¤„ ì„ íƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
    })
  }
}

// ===== ê¸°ì¡´ ë©”ì„œë“œë“¤ ìœ ì§€ =====

// ì…ë ¥ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
// ì¦ê°€ í•¨ìˆ˜ - ì…ë ¥ëœ ê°’ë§Œí¼ ì¦ê°€
const increment = async (index: number) => {
  // í˜„ì¬ ì¶œë ¥ê°’ (í˜„ì¬ ìƒíƒœ)
  const currentOutput = parseFloat(outputs.value[index] || '0')
  console.log('currentOutput:', currentOutput)
  // ì…ë ¥ëœ ê°’ (ì¦ê°€ëŸ‰)
  const inputValue = parseFloat(inputs.value[index] || '0')
  console.log('inputValue:', inputValue)
  // ìƒˆë¡œìš´ ê°’ ê³„ì‚° (í˜„ì¬ ì¶œë ¥ê°’ + ì…ë ¥ëœ ê°’)
  const newValue = (currentOutput + inputValue).toFixed(2)
  console.log('newValue:', newValue)
  // ì¶œë ¥ê°’ ì—…ë°ì´íŠ¸
  outputs.value[index] = newValue

  // ì˜¤í”„ì…‹ ì—…ë°ì´íŠ¸ (ì„œë²„ì— ì „ì†¡)
  await updateOffset(index, newValue)
}

// ê°ì†Œ í•¨ìˆ˜ - ì…ë ¥ëœ ê°’ë§Œí¼ ê°ì†Œ
const decrement = async (index: number) => {
  // í˜„ì¬ ì¶œë ¥ê°’ (í˜„ì¬ ìƒíƒœ)
  const currentOutput = parseFloat(outputs.value[index] || '0')

  // ì…ë ¥ëœ ê°’ (ê°ì†ŒëŸ‰)
  const inputValue = parseFloat(inputs.value[index] || '0')

  // ìƒˆë¡œìš´ ê°’ ê³„ì‚° (í˜„ì¬ ì¶œë ¥ê°’ - ì…ë ¥ëœ ê°’)
  const newValue = (currentOutput - inputValue).toFixed(2)

  // ì¶œë ¥ê°’ ì—…ë°ì´íŠ¸
  outputs.value[index] = newValue

  // ì˜¤í”„ì…‹ ì—…ë°ì´íŠ¸ (ì„œë²„ì— ì „ì†¡)
  await updateOffset(index, newValue)
}

// ë¦¬ì…‹ í•¨ìˆ˜
const reset = async (index: number) => {
  inputs.value[index] = '0.00'
  await updateOffset(index, '0.00')
}
// âœ… updateOffset í•¨ìˆ˜ ìˆ˜ì • - Time ì²˜ë¦¬ ë¶„ë¦¬
const updateOffset = async (index: number, value: string) => {
  try {
    // âœ… ë””ë²„ê¹… ë¡œê·¸ ì¶”ê°€
    console.log('updateOffset í˜¸ì¶œë¨:', {
      index,
      value,
      valueType: typeof value,
      inputs3: inputs.value[3],
      currentTimeResult: ephemerisStore.offsetValues.timeResult,
    })

    const numValue = Number(parseFloat(value).toFixed(2)) || 0
    console.log('ê³„ì‚°ëœ numValue:', numValue)

    const offsetTypes = ['azimuth', 'elevation', 'train', 'time'] as const
    const offsetType = offsetTypes[index]

    if (!offsetType) {
      console.error('Invalid offset index:', index)
      return
    }

    if (index === 3) {
      const timeInputValue = inputs.value[3] || '0.00'
      ephemerisStore.updateOffsetValues('time', timeInputValue)
      try {
        await ephemerisStore.sendTimeOffset(numValue)
        ephemerisStore.updateOffsetValues('timeResult', numValue.toFixed(2))
        console.log('Time Result ì—…ë°ì´íŠ¸:', numValue.toFixed(2))
      } catch (error) {
        console.error('Time offset command failed:', error)
      }
      return
    }

    // Position Offset ì²˜ë¦¬ (azimuth, elevation, train)
    ephemerisStore.updateOffsetValues(offsetType, numValue.toFixed(2))

    const azOffset = Number((parseFloat(ephemerisStore.offsetValues.azimuth) || 0).toFixed(2))
    const elOffset = Number((parseFloat(ephemerisStore.offsetValues.elevation) || 0).toFixed(2))
    const trainOffset = Number((parseFloat(ephemerisStore.offsetValues.train) || 0).toFixed(2))

    await icdStore.sendPositionOffsetCommand(azOffset, elOffset, trainOffset)
  } catch (error) {
    console.error('Error updating offset:', error)
  }
}
// ì…ë ¥ê°’ì´ ë³€ê²½ë  ë•Œ í˜¸ì¶œë˜ëŠ” í•¨ìˆ˜
const onInputChange = (index: number, value: string) => {
  console.log('onInputChange í˜¸ì¶œ:', { index, value, inputs: inputs.value })
  inputs.value[index] = value
  void updateOffset(index, value)
}

// ì„œë²„ ì‹œê°„ í¬ë§·íŒ…ì„ ìœ„í•œ ê³„ì‚°ëœ ì†ì„±
const formattedCalTime = computed(() => {
  const calTime = icdStore.resultTimeOffsetCalTime
  if (!calTime) return ''
  try {
    // ì„œë²„ ì‹œê°„ íŒŒì‹±
    const dateObj = new Date(calTime)

    // ìœ íš¨í•œ ë‚ ì§œì¸ì§€ í™•ì¸
    if (isNaN(dateObj.getTime())) {
      return calTime // ìœ íš¨í•˜ì§€ ì•Šì€ ë‚ ì§œë©´ ì›ë³¸ ë°˜í™˜
    }

    // UTC ê¸°ì¤€ìœ¼ë¡œ ì‹œê°„ í˜•ì‹ ì§€ì •
    const utcYear = dateObj.getFullYear()
    const utcMonth = String(dateObj.getMonth() + 1).padStart(2, '0')
    const utcDay = String(dateObj.getDate()).padStart(2, '0')
    const utcHours = String(dateObj.getHours()).padStart(2, '0')
    const utcMinutes = String(dateObj.getMinutes()).padStart(2, '0')
    const utcSeconds = String(dateObj.getSeconds()).padStart(2, '0')
    const utcMilliseconds = String(dateObj.getMilliseconds()).padStart(3, '0')

    // YYYY-MM-DD HH:MM:SS.mmm (UTC) í˜•ì‹
    return `${utcYear}-${utcMonth}-${utcDay} ${utcHours}:${utcMinutes}:${utcSeconds}.${utcMilliseconds} `
  } catch (e) {
    console.error('Error formatting cal time:', e)
    return calTime
  }
})

// TLE ê´€ë ¨ í•¨ìˆ˜ë“¤
const openTLEModal = () => {
  showTLEModal.value = true
  tempTLEData.value.tleText = ''
  tleError.value = null
}

// ì •ì§€ê¶¤ë„ íŒë³„ í•¨ìˆ˜ (í‰ê· ìš´ë™ë§Œ ì‚¬ìš©)
const isGeostationaryOrbit = (tleText: string): boolean => {
  try {
    const lines = tleText.trim().split('\n').filter(line => line.trim() !== '')

    if (lines.length < 2) return false

    // TLE Line 2 ì¶”ì¶œ (í‰ê· ìš´ë™ì´ ìˆëŠ” ë¼ì¸)
    const tleLine2 = lines.length >= 3 ? lines[2] : lines[1]

    if (!tleLine2 || tleLine2.length < 63) return false

    // í‰ê· ìš´ë™(Mean Motion) ì¶”ì¶œ (Line 2ì˜ 52-63ë²ˆì§¸ ë¬¸ì)
    const meanMotionStr = tleLine2.substring(52, 63).trim()
    const meanMotion = parseFloat(meanMotionStr)

    // ì •ì§€ê¶¤ë„ íŒë³„: í‰ê· ìš´ë™ì´ 1.0027 rev/dayì— ê°€ê¹Œìš´ì§€ í™•ì¸
    const isGEO = Math.abs(meanMotion - 1.0027) <= 0.1

    console.log('ì •ì§€ê¶¤ë„ íŒë³„:', {
      meanMotion,
      isGEO,
      tleLine2: tleLine2.substring(52, 63)
    })

    return isGEO
  } catch (error) {
    console.error('ì •ì§€ê¶¤ë„ íŒë³„ ì¤‘ ì˜¤ë¥˜:', error)
    return false
  }
}

const addTLEData = async () => {
  if (!tempTLEData.value.tleText.trim()) {
    tleError.value = 'TLE ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”'
    return
  }

  isProcessingTLE.value = true
  tleError.value = null

  try {
    // ì •ì§€ê¶¤ë„ ì—¬ë¶€ í™•ì¸ - ì „ì²´ TLE í…ìŠ¤íŠ¸ ì „ë‹¬
    const isGEO = isGeostationaryOrbit(tempTLEData.value.tleText)

    if (isGEO) {
      console.log('ì •ì§€ê¶¤ë„ TLE ê°ì§€ë¨ - ì •ì§€ê¶¤ë„ ê°ë„ ê³„ì‚°')

      // TLE íŒŒì‹±
      const lines = tempTLEData.value.tleText.trim().split('\n').filter(line => line.trim() !== '')

      // TLE ë¼ì¸ ì¶”ì¶œ (3ì¤„ í˜•ì‹ì¸ ê²½ìš° ìœ„ì„± ì´ë¦„ ì œì™¸)
      const tleLine1 = lines.length >= 3 ? lines[1] : lines[0]
      const tleLine2 = lines.length >= 3 ? lines[2] : lines[1]

      // TLE ë¼ì¸ì´ ìœ íš¨í•œì§€ í™•ì¸
      if (!tleLine1 || !tleLine2) {
        throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ TLE ë°ì´í„°ì…ë‹ˆë‹¤')
      }

      // âœ… ìœ„ì„± ì´ë¦„ê³¼ ID ì¶”ì¶œ
      let satelliteName = ''
      const satelliteId = tleLine1.substring(2, 7).trim() // TLE Line 1ì—ì„œ ìœ„ì„± ID ì¶”ì¶œ

      if (lines.length >= 3 && lines[0]) {
        // 3ì¤„ í˜•ì‹: ì²« ë²ˆì§¸ ì¤„ì´ ìœ„ì„± ì´ë¦„
        satelliteName = lines[0].trim()
      } else {
        // 2ì¤„ í˜•ì‹: ìœ„ì„± ì´ë¦„ì€ IDì™€ ë™ì¼í•˜ê²Œ ì„¤ì • (êµ¬ë¶„ì„ ìœ„í•´)
        satelliteName = satelliteId
      }

      // ì •ì§€ê¶¤ë„ ê°ë„ ê³„ì‚° (ì¶”ì  ì‹œì‘í•˜ì§€ ì•ŠìŒ)
      await ephemerisStore.calculateGeostationaryAngles(tleLine1, tleLine2, satelliteName)

      // âœ… TLE í‘œì‹œ ë°ì´í„° ì—…ë°ì´íŠ¸
      ephemerisStore.updateTLEDisplayData({
        displayText: tempTLEData.value.tleText,
        tleLine1: tleLine1,
        tleLine2: tleLine2,
        satelliteName: satelliteName,
      })

      // âœ… ì •ì§€ê¶¤ë„ TLE ì…ë ¥ ì‹œ ìŠ¤ì¼€ì¤„ ë°ì´í„° ì™„ì „ ì´ˆê¸°í™”
      ephemerisStore.clearScheduleData()
    }
    else {
      await ephemerisStore.processTLEData(tempTLEData.value.tleText)

      // âœ… ì €ê¶¤ë„ TLE ì…ë ¥ ì‹œ í•­ìƒ ìŠ¤ì¼€ì¤„ ë°ì´í„° ë¡œë“œ (ê°•ì œ ìƒˆë¡œê³ ì¹¨)
      await loadScheduleData()
    }

    $q.notify({
      type: 'positive',
      message: `TLE ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤${isGEO ? ' (ì •ì§€ê¶¤ë„)' : ''}`,
    })

    showTLEModal.value = false
  } catch (error) {
    console.error('TLE ì²˜ë¦¬ ì‹¤íŒ¨:', error)
    tleError.value = error instanceof Error ? error.message : 'TLE ë°ì´í„° ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤'
  } finally {
    isProcessingTLE.value = false
  }
}

// ìŠ¤ì¼€ì¤„ ëª¨ë‹¬ ê´€ë ¨
const openScheduleModal = async () => {
  showScheduleModal.value = true

  // âœ… ì •ì§€ê¶¤ë„ ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ ìŠ¤ì¼€ì¤„ ë°ì´í„° ë¡œë“œ
  if (!ephemerisStore.geostationaryAngles.isSet) {
    await loadScheduleData()
  }
}

// ëª…ë ¹ ì‹¤í–‰ í•¨ìˆ˜ë“¤
const handleEphemerisCommand = async () => {
  try {
    // âœ… ì •ì§€ê¶¤ë„ ê°ë„ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì •ì§€ê¶¤ë„ ì¶”ì  ì‹œì‘
    if (ephemerisStore.geostationaryAngles.isSet) {
      // ì •ì§€ê¶¤ë„ ì¶”ì  í™œì„±í™”
      ephemerisStore.activateGeostationaryTracking()

      // ë°±ì—”ë“œì— ì¶”ì  ì‹œì‘ ëª…ë ¹ ì „ì†¡
      if (ephemerisStore.geostationaryAngles.tleLine1 && ephemerisStore.geostationaryAngles.tleLine2) {
        await ephemerisStore.startGeostationaryTracking(
          ephemerisStore.geostationaryAngles.tleLine1,
          ephemerisStore.geostationaryAngles.tleLine2
        )
      }

      $q.notify({
        type: 'positive',
        message: `ì •ì§€ê¶¤ë„ ìœ„ì„±(${ephemerisStore.geostationaryAngles.satelliteName}) ì¶”ì ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤`,
      })
      return
    }

    // ê¸°ì¡´ ìŠ¤ì¼€ì¤„ ì¶”ì  ë¡œì§
    if (!selectedScheduleInfo.value.passId) {
      $q.notify({
        type: 'warning',
        message: 'ë¨¼ì € ìŠ¤ì¼€ì¤„ì„ ì„ íƒí•˜ê±°ë‚˜ TLEë¥¼ ì…ë ¥í•˜ì„¸ìš”',
      })
      return
    }

    // âœ… ì¶”ì  ì‹œì‘ ì „ ê²½ë¡œ ì´ˆê¸°í™” (í˜„ì¬ ìœ„ì¹˜ ê¸°ì¤€)
    const currentAzimuth = parseFloat(icdStore.azimuthAngle) || 0
    const currentElevation = parseFloat(icdStore.elevationAngle) || 0

    ephemerisStore.clearTrackingPath(currentAzimuth, currentElevation)
    await ephemerisStore.startTracking()

    $q.notify({
      type: 'positive',
      message: 'Ephemeris ì¶”ì ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤',
    })
  } catch (error) {
    console.error('Failed to start tracking:', error)
    $q.notify({
      type: 'negative',
      message: 'ì¶”ì  ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
    })
  }
}

const handleStopCommand = async () => {
  try {
    // âœ… ê¸°ì¡´ ephemeris ì¶”ì  ì¤‘ì§€ API ì‚¬ìš© (í•˜ë“œì›¨ì–´ + ì†Œí”„íŠ¸ì›¨ì–´ ìƒíƒœ ëª¨ë‘ ì²˜ë¦¬)
    await ephemerisTrackService.stopEphemerisTracking()

    // âœ… í•˜ë“œì›¨ì–´ ì •ì§€ ëª…ë ¹ë„ í•¨ê»˜ ì „ì†¡
    await icdStore.stopCommand(true, true, true)

    // âœ… í”„ë¡ íŠ¸ì—”ë“œ ìƒíƒœ ì—…ë°ì´íŠ¸
    await ephemerisStore.stopTracking()

    // âœ… Stop ë²„íŠ¼ í´ë¦­ ì‹œ ì‹¤ì‹œê°„ ê²½ë¡œ ì´ˆê¸°í™”
    ephemerisStore.clearTrackingPath()
    console.log('ğŸ›‘ Stop ë²„íŠ¼ í´ë¦­ - ì¶”ì  ì¤‘ì§€ ë° ìƒíƒœ ë³€ê²½')

    $q.notify({
      type: 'positive',
      message: 'ì •ì§€ ëª…ë ¹ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤',
    })
  } catch (error) {
    console.error('Failed to send stop command:', error)
    $q.notify({
      type: 'negative',
      message: 'ì •ì§€ ëª…ë ¹ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
    })
  }
}

const handleStowCommand = async () => {
  try {
    await icdStore.stowCommand()

    $q.notify({
      type: 'positive',
      message: 'Stow ëª…ë ¹ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤',
    })
  } catch (error) {
    console.error('Failed to send stow command:', error)
    $q.notify({
      type: 'negative',
      message: 'Stow ëª…ë ¹ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤',
    })
  }
}

// ATC íŒì—… ì—´ê¸°
const openAxisTransformCalculator = () => {
  try {
    openPopup('axis-transform-calculator', {
      width: 800,
      height: 600,
      title: '3ì¶• ë³€í™˜ ê³„ì‚°ê¸°'
    })
  } catch (error) {
    console.error('ATC íŒì—… ì—´ê¸° ì‹¤íŒ¨:', error)
    $q.notify({
      type: 'negative',
      message: 'ATC íŒì—…ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
      timeout: 3000
    })
  }
}

// ëª¨ë“  MST ë°ì´í„°ë¥¼ CSVë¡œ ë‚´ë³´ë‚´ê¸°
const exportAllMstDataToCsv = async () => {
  if (isExportingCsv.value) return

  isExportingCsv.value = true

  try {
    $q.notify({
      type: 'info',
      message: 'ì´ë¡ ì¹˜ ë°ì´í„°ë¥¼ CSVë¡œ ë‚´ë³´ë‚´ëŠ” ì¤‘...',
      timeout: 2000
    })

    const response = await ephemerisTrackService.exportAllMstDataToCsv()

    if (response.success) {
      $q.notify({
        type: 'positive',
        message: `ì´ë¡ ì¹˜ ë°ì´í„° ë‚´ë³´ë‚´ê¸° ì™„ë£Œ! ì´ ${response.totalMstCount}ê°œ MST, ${response.successCount}ê°œ ì„±ê³µ`,
        timeout: 5000
      })

      console.log('CSV ë‚´ë³´ë‚´ê¸° ê²°ê³¼:', response)
    } else {
      $q.notify({
        type: 'negative',
        message: `ì´ë¡ ì¹˜ ë°ì´í„° ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨: ${response.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`,
        timeout: 5000
      })
    }
  } catch (error) {
    console.error('CSV ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨:', error)
    $q.notify({
      type: 'negative',
      message: 'ì´ë¡ ì¹˜ ë°ì´í„° ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
      timeout: 5000
    })
  } finally {
    isExportingCsv.value = false
  }
}
// âœ… ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ê°ì§€
let mainThreadBlockingDetector: number | null = null

const startMainThreadMonitoring = () => {
  let lastCheck = performance.now()

  const checkMainThread = () => {
    const currentTime = performance.now()
    const timeDiff = currentTime - lastCheck

    // âœ… ì˜ˆìƒë³´ë‹¤ ì˜¤ë˜ ê±¸ë ¸ë‹¤ë©´ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ë¸”ë¡œí‚¹ë˜ì—ˆìŒ
    if (timeDiff > 50) {
      // 10ms ì²´í¬ ê°„ê²©ì—ì„œ 50ms ì´ìƒì´ë©´ ë¸”ë¡œí‚¹
      console.warn(`ğŸš« ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ê°ì§€: ${timeDiff.toFixed(2)}ms`)
    }

    lastCheck = currentTime
    mainThreadBlockingDetector = requestAnimationFrame(checkMainThread)
  }

  mainThreadBlockingDetector = requestAnimationFrame(checkMainThread)
}
let lastTimerExecution = 0
const timerIntervalStats = {
  totalExecutions: 0,
  totalInterval: 0,
  maxInterval: 0,
  minInterval: Infinity,
}

// ===== ë¼ì´í”„ì‚¬ì´í´ í›… =====

onMounted(async () => {
  console.log('EphemerisDesignation ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ë¨')
  // âœ… ë©”ì¸ ìŠ¤ë ˆë“œ ëª¨ë‹ˆí„°ë§ ì‹œì‘
  startMainThreadMonitoring()
  // ì°¨íŠ¸ ì´ˆê¸°í™”
  setTimeout(() => {
    initChart()
  }, 100)
  // âœ… ìŠ¤í† ì–´ì—ì„œ ì˜¤í”„ì…‹ ê°’ ë³µì›
  inputs.value = [
    ephemerisStore.offsetValues.azimuth,
    ephemerisStore.offsetValues.elevation,
    ephemerisStore.offsetValues.train,
    ephemerisStore.offsetValues.time,
  ]

  // âœ… ìŠ¤í† ì–´ì— ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¡œë“œ (íƒ­ ì´ë™ ì‹œì—ë„ ë°ì´í„° ìœ ì§€)
  if (ephemerisStore.masterData.length === 0) {
    await loadScheduleData()
  }

  // âœ… ì´ë¯¸ ì„ íƒëœ ìŠ¤ì¼€ì¤„ì´ ìˆìœ¼ë©´ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
  if (ephemerisStore.selectedSchedule && ephemerisStore.detailData.length > 0) {
    setTimeout(() => {
      if (chart) {
        updateChartWithTrajectory([...ephemerisStore.detailData] as TrajectoryPoint[])
      }
    }, 200)
  }
  // âœ… ì¶”ê°€: ê¸°ì¡´ ì¶”ì  ê²½ë¡œê°€ ìˆìœ¼ë©´ ì°¨íŠ¸ì— ë³µì›
  if (ephemerisStore.trackingPath.sampledPath.length > 0) {
    setTimeout(() => {
      if (chart) {
        const updateOption = {
          series: [
            {},
            {},
            {
              data: [...ephemerisStore.trackingPath.sampledPath],
            },
            {},
          ],
        } as unknown as Parameters<typeof chart.setOption>[0]
        chart.setOption(updateOption)
      }
    }, 300)
  }
  // ì°¨íŠ¸ ì—…ë°ì´íŠ¸ íƒ€ì´ë¨¸ ì‹œì‘
  updateTimer = window.setInterval(() => {
    const currentTime = performance.now()

    if (lastTimerExecution > 0) {
      const interval = currentTime - lastTimerExecution
      timerIntervalStats.totalExecutions++
      timerIntervalStats.totalInterval += interval
      timerIntervalStats.maxInterval = Math.max(timerIntervalStats.maxInterval, interval)
      timerIntervalStats.minInterval = Math.min(timerIntervalStats.minInterval, interval)

      // âœ… íƒ€ì´ë¨¸ ê°„ê²©ì´ 150ms ì´ìƒì´ë©´ ê²½ê³ 
      if (interval > 150) {
        console.warn(`â° íƒ€ì´ë¨¸ ì§€ì—° ê°ì§€: ${interval.toFixed(2)}ms (ëª©í‘œ: 100ms)`)
      }

      // âœ… 100ë²ˆë§ˆë‹¤ íƒ€ì´ë¨¸ í†µê³„ ì¶œë ¥
      if (timerIntervalStats.totalExecutions % 100 === 0) {
        const avgInterval = timerIntervalStats.totalInterval / timerIntervalStats.totalExecutions
        console.log(`â° íƒ€ì´ë¨¸ í†µê³„:`, {
          í‰ê· ê°„ê²©: avgInterval.toFixed(2) + 'ms',
          ìµœëŒ€ê°„ê²©: timerIntervalStats.maxInterval.toFixed(2) + 'ms',
          ìµœì†Œê°„ê²©: timerIntervalStats.minInterval.toFixed(2) + 'ms',
          ëª©í‘œê°„ê²©: '100ms',
        })
      }
    }

    lastTimerExecution = currentTime
    void updateChart()
    updateTimeRemaining()
  }, 100)

  // ì‹œê°„ ì—…ë°ì´íŠ¸ íƒ€ì´ë¨¸ ì‹œì‘
  timeUpdateTimer = window.setInterval(() => {
    updateTimeRemaining()
  }, 1000)
})

onUnmounted(() => {
  console.log('EphemerisDesignation ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ë¨')

  // íƒ€ì´ë¨¸ ì •ë¦¬
  if (updateTimer) {
    clearInterval(updateTimer)
    updateTimer = null
  }

  if (timeUpdateTimer) {
    clearInterval(timeUpdateTimer)
    timeUpdateTimer = null
  }

  // ì°¨íŠ¸ ì •ë¦¬
  if (chart) {
    chart.dispose()
    chart = null
  }
  // âœ… ë©”ì¸ ìŠ¤ë ˆë“œ ëª¨ë‹ˆí„°ë§ ì •ë¦¬
  if (mainThreadBlockingDetector) {
    cancelAnimationFrame(mainThreadBlockingDetector)
  }
  // âœ… ì¶”ê°€: ì¶”ì  ê²½ë¡œ ì •ë¦¬ (ë©”ëª¨ë¦¬ ì ˆì•½)
  ephemerisStore.clearTrackingPath()
  // âœ… TypeScript Worker ì •ë¦¬
  ephemerisStore.cleanupWorker()
  // ìœˆë„ìš° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
  window.removeEventListener('resize', () => { })
})
</script>

<style scoped>
.ephemeris-mode {
  height: 100%;
  width: 100%;
}

.ephemeris-container {
  padding: 0px !important;
  padding-top: 1px !important;
  /* ìƒë‹¨ íŒ¨ë”© 1pxë¡œ ì„¤ì • */
  width: 100%;
  height: 100%;
  margin-top: 0px !important;
  /* ìƒë‹¨ ë§ˆì§„ ì œê±° */
}

.section-title {
  font-weight: 500;
  padding-left: 0.5rem;
}


.control-section {
  height: 100%;
  max-height: 450px;
  width: 100%;
  background-color: var(--theme-card-background);
  border: 1px solid rgba(255, 255, 255, 0.12);
}

.chart-area {
  height: 400px;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 0.5rem;
}

.ephemeris-form {
  margin-top: 0.5rem;
  width: 100%;
}

.form-row {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  width: 100%;
}

.button-group {
  display: flex;
  gap: 0.25rem;
  margin-top: 0.5rem;
  width: 100%;
  justify-content: space-between;
}

.full-width {
  width: 100%;
}

.tle-editor {
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 4px;
}

.tle-display {
  font-family: monospace !important;
  background-color: var(--theme-card-background);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 4px;
  min-height: 80px;
}

/* ìŠ¤ì¼€ì¤„ í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
.schedule-table {
  background-color: var(--theme-card-background);
  color: white;
}

/* âœ… ìŠ¤ì¼€ì¤„ ì •ë³´ í‘œì‹œ ìŠ¤íƒ€ì¼ */
.schedule-info {
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  padding: 16px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.info-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.info-row:last-child {
  border-bottom: none;
}

.info-label {
  font-weight: 500;
  color: #90caf9;
  min-width: 120px;
}

.info-value {
  font-weight: 400;
  color: #ffffff;
  text-align: right;
  flex: 1;
}

/* ì»´íŒ©íŠ¸ ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ */
.compact-control {
  padding: 0.5rem !important;
}

.compact-control .q-input {
  margin-bottom: 0.25rem !important;
}

.compact-control .q-btn {
  min-height: 2rem !important;
  padding: 0.25rem !important;
}

/* ê°€ë¡œ ë°°ì¹˜ë¥¼ ìœ„í•œ ì •ë ¬ ìŠ¤íƒ€ì¼ */
.align-center {
  align-items: center !important;
}

.justify-end {
  justify-content: flex-end;
}

.justify-center {
  justify-content: center;
}

/* ì…ë ¥ì°½ê³¼ ë²„íŠ¼ì´ ê°™ì€ ë†’ì´ì— ì˜¤ë„ë¡ */
.compact-control .row.align-center {
  display: flex !important;
  align-items: center !important;
  flex-wrap: nowrap !important;
}

.compact-control .q-field {
  margin-bottom: 0 !important;
}

/* ëª¨ë“  ìš”ì†Œê°€ í•œ ì¤„ì— ë°°ì¹˜ë˜ë„ë¡ ê°•ì œ */
.compact-control .row {
  display: flex !important;
  flex-wrap: nowrap !important;
  align-items: center !important;
}

.compact-control .col-3,
.compact-control .col-6,
.compact-control .col-2,
.compact-control .col-4 {
  flex-shrink: 0 !important;
}

/* ê°•ì œ ê°€ë¡œ ë°°ì¹˜ */
.compact-control .row {
  display: flex !important;
  flex-direction: row !important;
  flex-wrap: nowrap !important;
  align-items: center !important;
  width: 100% !important;
}

.compact-control .col-3,
.compact-control .col-6,
.compact-control .col-2,
.compact-control .col-4 {
  display: flex !important;
  flex-direction: column !important;
  justify-content: center !important;
  align-items: stretch !important;
}

/* ì…ë ¥ì°½ê³¼ ë²„íŠ¼ ì»¨í…Œì´ë„ˆ */
.compact-control .row .row {
  display: flex !important;
  flex-direction: row !important;
  justify-content: center !important;
  align-items: center !important;
  gap: 0.25rem !important;
}

/* ë¼ë²¨ê³¼ ì…ë ¥ì°½ì„ ê°™ì€ ë†’ì´ì— ë°°ì¹˜ */
.compact-control .text-subtitle2 {
  display: flex !important;
  align-items: center !important;
  height: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
}

/* ë¼ë²¨ ì»¨í…Œì´ë„ˆ */
.compact-control .col-1 {
  display: flex !important;
  align-items: center !important;
  justify-content: flex-start !important;
  min-width: fit-content !important;
}

/* ë¼ë²¨ í…ìŠ¤íŠ¸ í¬ê¸° ì¡°ì • */
.compact-control .text-subtitle2 {
  font-size: 0.9rem !important;
  white-space: nowrap !important;
}

/* ê°„ê²© ì œê±°ë¡œ ë” íƒ€ì´íŠ¸í•˜ê²Œ */
.compact-control .row.q-gutter-none {
  margin: 0 !important;
  padding: 0 !important;
}

.compact-control .row.q-gutter-none>div {
  padding-left: 0.25rem !important;
  padding-right: 0.25rem !important;
}

.compact-control .row.q-gutter-none>div:first-child {
  padding-left: 0 !important;
}

.compact-control .row.q-gutter-none>div:last-child {
  padding-right: 0 !important;
}

/* âœ… ìƒˆë¡œìš´ ì„¸ë¡œ ë²„íŠ¼ ë ˆì´ì•„ì›ƒ */
.vertical-button-group {
  display: flex !important;
  align-items: center !important;
  gap: 4px !important;
}

.vertical-buttons {
  display: flex !important;
  flex-direction: column !important;
  gap: 2px !important;
}

/* âœ… ë°©ë²• 1: ì™¼ìª½ ì„¸ë¡œ ë¼ë²¨ (ì¹´ë“œ ì•ˆ) - ë†’ì´ ìµœì í™” */
.position-offset-label {
  background: linear-gradient(135deg, rgba(25, 118, 210, 0.15) 0%, rgba(25, 118, 210, 0.08) 100%);
  padding: 4px 8px;
  /* ë†’ì´ ì¤„ì„: 8px 12px â†’ 4px 8px */
  border-radius: 6px;
  border-right: 3px solid var(--q-primary);
  min-width: 50px;
  /* ë„ˆë¹„ë„ ì•½ê°„ ì¤„ì„: 60px â†’ 50px */
  margin-right: 6px;
  /* ê°„ê²©ë„ ì¤„ì„: 8px â†’ 6px */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: relative;
  overflow: hidden;
}

.position-offset-label .text-subtitle2 {
  font-size: 0.8rem !important;
  /* í…ìŠ¤íŠ¸ í¬ê¸° ì¤„ì„ */
  line-height: 1.2 !important;
  /* ì¤„ ê°„ê²© ì¤„ì„ */
}

/* âœ… ë°©ë²• 1: ì™¼ìª½ ì„¸ë¡œ ë¼ë²¨ (ì¹´ë“œ ì•ˆ) - ë†’ì´ ìµœì í™” */
.position-offset-label {
  background: linear-gradient(135deg, rgba(25, 118, 210, 0.15) 0%, rgba(25, 118, 210, 0.08) 100%);
  padding: 4px 8px;
  /* ë†’ì´ ì¤„ì„: 8px 12px â†’ 4px 8px */
  border-radius: 6px;
  border-right: 3px solid var(--q-primary);
  min-width: 50px;
  /* ë„ˆë¹„ë„ ì•½ê°„ ì¤„ì„: 60px â†’ 50px */
  margin-right: 6px;
  /* ê°„ê²©ë„ ì¤„ì„: 8px â†’ 6px */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: relative;
  overflow: hidden;
}

.position-offset-label .text-subtitle2 {
  font-size: 0.8rem !important;
  /* í…ìŠ¤íŠ¸ í¬ê¸° ì¤„ì„ */
  line-height: 1.2 !important;
  /* ì¤„ ê°„ê²© ì¤„ì„ */
}

/* âœ… ì¹´ë“œ í…Œë‘ë¦¬ ìœ„ì•„ë˜ íŒ¨ë”© ì™„ì „ ì œê±° - ë” êµ¬ì²´ì ì¸ ì…€ë ‰í„° */
.q-card.control-card .q-card-section.compact-control {
  padding: 0px 8px !important;
  /* ìƒí•˜ íŒ¨ë”©ì„ ì™„ì „íˆ ì œê±° */
}

/* âœ… ì¶”ê°€ì ì¸ ê°•ì œ ì ìš© */
.q-card-section.compact-control {
  padding-top: 0px !important;
  padding-bottom: 0px !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
}

/* âœ… ë” ê°•ë ¥í•œ ê°•ì œ ì ìš© - ëª¨ë“  ê°€ëŠ¥í•œ ì…€ë ‰í„° */
.q-card-section.compact-control.purple-1,
.q-card.control-card .q-card-section.compact-control.purple-1,
.q-card-section[class*="compact-control"],
.q-card-section[class*="purple-1"] {
  padding-top: 0px !important;
  padding-bottom: 0px !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
  margin-top: 0px !important;
  margin-bottom: 0px !important;
  min-height: auto !important;
  height: auto !important;
  line-height: 1 !important;
  vertical-align: top !important;
  display: flex !important;
  align-items: flex-start !important;
}

/* âœ… Quasar ê¸°ë³¸ ìŠ¤íƒ€ì¼ ë®ì–´ì“°ê¸° */
.q-card-section {
  padding-top: 0px !important;
  padding-bottom: 0px !important;
  line-height: 1 !important;
  vertical-align: top !important;
}

/* âœ… ì¹´ë“œ ìì²´ ë§ˆì§„ë„ ì œê±° */
.q-card.control-card {
  margin-bottom: 0px !important;
  min-height: auto !important;
  height: auto !important;
  line-height: 1 !important;
  vertical-align: top !important;
}

.q-card.control-card .q-card__section {
  padding-top: 0px !important;
  padding-bottom: 0px !important;
  min-height: auto !important;
  height: auto !important;
  line-height: 1 !important;
  vertical-align: top !important;
}

/* âœ… ì¶”ê°€ ë†’ì´ ì¤„ì´ê¸° - ëª¨ë“  ìš”ì†Œì˜ ë†’ì´ ìµœì†Œí™” */
.q-input {
  min-height: auto !important;
  /* ì…ë ¥ í•„ë“œ ë†’ì´ ì›ë˜ëŒ€ë¡œ */
}

.q-field__control {
  min-height: auto !important;
  /* í•„ë“œ ì»¨íŠ¸ë¡¤ ë†’ì´ ì›ë˜ëŒ€ë¡œ */
}

.q-field__native {
  padding: auto !important;
  /* í•„ë“œ ë‚´ë¶€ íŒ¨ë”© ì›ë˜ëŒ€ë¡œ */
}

.q-btn {
  min-height: auto !important;
  /* ë²„íŠ¼ ë†’ì´ ì›ë˜ëŒ€ë¡œ */
}

.q-btn--dense {
  min-height: auto !important;
  /* ì¡°ë°€í•œ ë²„íŠ¼ ë†’ì´ ì›ë˜ëŒ€ë¡œ */
}

/* âœ… ë¼ë²¨ í…Œë‘ë¦¬ ë†’ì´ë§Œ ì¤„ì´ê¸° - ë‚´ë¶€ êµ¬ì„±ì€ ìœ ì§€ */
.position-offset-label {
  padding: 4px 8px !important;
  /* ë‚´ë¶€ íŒ¨ë”© ì›ë˜ëŒ€ë¡œ ìœ ì§€ */
  min-width: 50px !important;
  /* ë¼ë²¨ ë„ˆë¹„ ì›ë˜ëŒ€ë¡œ */
  border-right: 1px solid var(--q-primary) !important;
  /* í…Œë‘ë¦¬ ë‘ê»˜ë§Œ ì¤„ì„: 3px â†’ 1px */
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
  /* ê·¸ë¦¼ìë„ ì¤„ì„ */
}

.position-offset-label .text-subtitle2 {
  font-size: 0.8rem !important;
  /* í…ìŠ¤íŠ¸ í¬ê¸° ì›ë˜ëŒ€ë¡œ */
  line-height: 1.2 !important;
  /* ì¤„ ê°„ê²© ì›ë˜ëŒ€ë¡œ */
}

/* âœ… ëª¨ë“  ê°œë³„ í…Œë‘ë¦¬ ìŠ¤íƒ€ì¼ - í†µí•© í…Œë‘ë¦¬ì™€ ë™ì¼í•˜ê²Œ */
.azimuth-control-card,
.elevation-control-card,
.tilt-control-card,
.time-control-card {
  margin-bottom: 0px !important;
  min-height: auto !important;
  height: auto !important;
}

.azimuth-control-section,
.elevation-control-section,
.tilt-control-section,
.time-control-section {
  padding: 0px 8px !important;
  padding-top: 0px !important;
  padding-bottom: 0px !important;
  margin: 0px !important;
  min-height: auto !important;
  height: auto !important;
  line-height: 1 !important;
  vertical-align: top !important;
}

.azimuth-control-section .row,
.elevation-control-section .row,
.tilt-control-section .row,
.time-control-section .row {
  margin: 0px !important;
  padding: 0px !important;
  min-height: auto !important;
  height: auto !important;
}

.azimuth-control-section .row>div,
.elevation-control-section .row>div,
.tilt-control-section .row>div,
.time-control-section .row>div {
  margin: 0px !important;
  padding: 0px !important;
  min-height: auto !important;
  height: auto !important;
}

/* âœ… Quasar ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì™„ì „ ë®ì–´ì“°ê¸° */
.q-row {
  margin: 0px !important;
  padding: 0px !important;
}

.q-col {
  margin: 0px !important;
  padding: 0px !important;
}

/* ê°„ê²© ì œê±°ë¡œ ë” íƒ€ì´íŠ¸í•˜ê²Œ */
.compact-control .row.q-gutter-none {
  margin: 0 !important;
  padding: 0 !important;
}

.compact-control .row.q-gutter-none>div {
  padding-left: 0.25rem !important;
  padding-right: 0.25rem !important;
}

.compact-control .row.q-gutter-none>div:first-child {
  padding-left: 0 !important;
}

.compact-control .row.q-gutter-none>div:last-child {
  padding-right: 0 !important;
}
</style>

<style>
/* âœ… ì „ì—­ ìŠ¤íƒ€ì¼ ì œê±°í•˜ê³  scopedë¡œ ë³€ê²½ */
.q-field__control {
  padding: 0 8px;
}

.q-card__section {
  padding: 16px;
}

/* âœ… ì „ì—­ q-card ìŠ¤íƒ€ì¼ ì œê±° - ì´ê²ƒì´ ë¬¸ì œì˜ ì›ì¸ */
/* .q-card {
  background: var(--q-dark);
  box-shadow: 0 1px 5px rgb(0 0 0 / 20%), 0 2px 2px rgb(0 0 0 / 14%), 0 3px 1px -2px rgb(0 0 0 / 12%);
} */

/* âœ… EphemerisDesignationPage ë‚´ë¶€ì˜ q-cardë§Œ ìŠ¤íƒ€ì¼ ì ìš© */
.ephemeris-mode .q-card {
  background: var(--theme-card-background);
  box-shadow: 0 1px 5px rgb(0 0 0 / 20%), 0 2px 2px rgb(0 0 0 / 14%), 0 3px 1px -2px rgb(0 0 0 / 12%);
}


.q-btn {
  flex: 1;
}

/* âœ… ê°•ë ¥í•œ ì „ì—­ ìŠ¤íƒ€ì¼ ì˜¤ë²„ë¼ì´ë“œ */
.ephemeris-mode .q-field.fixed-input,
.ephemeris-mode .q-field.fixed-output {
  width: 30px !important;
  min-width: 30px !important;
  max-width: 30px !important;
  flex: 0 0 30px !important;
}

.ephemeris-mode .q-field.fixed-input .q-field__control,
.ephemeris-mode .q-field.fixed-output .q-field__control {
  width: 30px !important;
  min-width: 30px !important;
  max-width: 30px !important;
  flex: 0 0 30px !important;
}

.ephemeris-mode .q-field.fixed-input .q-field__native,
.ephemeris-mode .q-field.fixed-output .q-field__native {
  width: 30px !important;
  min-width: 30px !important;
  max-width: 30px !important;
  padding: 0 4px !important;
  font-size: 12px !important;
}

/* ë‚˜ë¨¸ì§€ ìŠ¤íƒ€ì¼ì€ ê·¸ëŒ€ë¡œ ìœ ì§€... */
</style>
